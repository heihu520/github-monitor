# 技术设计文档：星标历史追踪

## Context
当前GitHub监控系统仅存储仓库的实时快照数据，缺少历史趋势分析能力。此功能将引入时间序列数据存储和可视化，涉及数据库架构变更、新的后台任务调度和前端图表组件。

### 约束
- GitHub API速率限制：5000次/小时（已认证）
- 数据库存储成本：需要优化存储策略
- 查询性能：用户期望图表加载时间 < 1秒
- 历史数据保留：免费用户30天，付费用户1年

### 利益相关者
- 用户：获得趋势分析能力
- 开发团队：需要维护新的数据管道
- 运维团队：需要监控新的后台任务和存储增长

## Goals / Non-Goals

### Goals
- ✅ 追踪仓库星标数的每日变化
- ✅ 提供可视化的星标增长曲线
- ✅ 支持历史数据查询和导出
- ✅ 实现自动化的数据采集流程
- ✅ 确保查询性能在可接受范围内

### Non-Goals
- ❌ 实时星标数更新（每日采集足够）
- ❌ 追踪单个星标用户的详细信息
- ❌ 预测未来星标增长趋势（未来可能添加）
- ❌ 支持小时级别的历史数据粒度

## Decisions

### 决策1：数据存储策略
**选择**：使用PostgreSQL存储时间序列数据，每个仓库每天一条记录

**原因**：
- PostgreSQL已是项目主数据库，无需引入新依赖
- 每日粒度足够满足趋势分析需求
- 存储成本可控（每个仓库每年约36KB）
- 支持高效的时间范围查询

**备选方案考虑**：
- InfluxDB（时序数据库）：增加系统复杂度，对于每日粒度来说过度设计
- MongoDB：缺少PostgreSQL的ACID保证和复杂查询能力
- 小时级数据：存储成本增加24倍，但用户需求不强烈

### 决策2：数据采集调度策略
**选择**：使用Celery Beat进行分层调度
- 热门仓库（1000+ stars）：每小时采集
- 普通仓库（100-1000 stars）：每6小时采集
- 低活跃仓库（<100 stars）：每24小时采集

**原因**：
- 平衡API速率限制和数据新鲜度
- 热门仓库变化快，需要更频繁更新
- 根据活跃度分层可优化资源使用

**备选方案考虑**：
- 统一每日采集：数据不够及时，用户体验差
- 实时采集：超出API限制，成本过高
- Webhook方式：GitHub Webhook不提供星标变化事件

### 决策3：前端图表库选择
**选择**：使用ECharts

**原因**：
- 功能强大，支持丰富的交互和定制
- 良好的Vue 3集成（vue-echarts）
- 性能优秀，能处理大数据集
- 开源免费，社区活跃

**备选方案考虑**：
- Chart.js：功能较简单，缺少高级交互
- D3.js：学习曲线陡峭，开发成本高
- Recharts：React生态，不适合Vue项目

### 决策4：数据聚合策略
**选择**：支持按天/周/月三种粒度查询，后端实时聚合

**原因**：
- 灵活性高，满足不同时间范围的查看需求
- 实时聚合避免预计算的存储开销
- PostgreSQL的窗口函数性能足够好

**实现**：
```sql
-- 按周聚合示例
SELECT 
  DATE_TRUNC('week', recorded_at) as week,
  AVG(star_count) as avg_stars,
  MAX(star_count) - MIN(star_count) as weekly_growth
FROM star_history
WHERE repository_id = ?
  AND recorded_at >= ?
  AND recorded_at <= ?
GROUP BY week
ORDER BY week;
```

### 决策5：缓存策略
**选择**：Redis缓存查询结果，TTL根据数据新鲜度设置
- 当日数据：1小时TTL
- 历史数据（>7天）：24小时TTL
- 缓存key格式：`star_history:{repo_id}:{start}:{end}:{interval}`

**原因**：
- 减少数据库负载
- 加快常见查询响应速度
- 历史数据不变，可以长期缓存

## Risks / Trade-offs

### 风险1：GitHub API速率限制
**风险**：大量仓库同时采集可能超出API限制

**缓解措施**：
- 实现智能速率限制器，监控剩余配额
- 采集失败时使用指数退避重试
- 优先级队列：重要仓库优先采集
- 考虑使用GitHub GraphQL API批量查询（减少API调用）

### 风险2：数据库存储增长
**风险**：长期运行后历史数据可能占用大量空间

**缓解措施**：
- 实施数据保留策略（免费用户30天，付费1年）
- 定期归档老数据到冷存储
- 添加存储监控和告警
- 考虑数据压缩策略

### 权衡1：实时性 vs API成本
**权衡**：选择每日采集而非实时更新

**影响**：
- ✅ 优点：API调用可控，成本低
- ❌ 缺点：数据有最多24小时延迟
- **决定**：对于趋势分析场景，每日更新足够

### 权衡2：存储完整历史 vs 存储成本
**权衡**：免费用户只保留30天历史

**影响**：
- ✅ 优点：控制存储成本，提供付费用户价值
- ❌ 缺点：免费用户功能受限
- **决定**：合理的免费增值模式

## Migration Plan

### 阶段1：数据库迁移（第1天）
1. 创建`star_history`表和索引
2. 在staging环境测试迁移
3. 在生产环境执行迁移（预计停机时间：0分钟，在线迁移）
4. 验证表结构和索引

### 阶段2：后端部署（第2-3天）
1. 部署新的API端点（向后兼容）
2. 启动数据采集任务（初始采集）
3. 监控任务执行状态和API性能
4. 回填最近7天的历史数据（如果GitHub API支持）

### 阶段3：前端发布（第4-5天）
1. 部署前端组件（功能开关控制）
2. 小范围用户测试（Beta版）
3. 收集反馈并优化
4. 全量发布

### 回滚计划
- **数据库**：保留迁移脚本的回滚版本
- **后端**：通过功能开关禁用新端点
- **前端**：隐藏新组件，回退到旧版本
- **数据**：star_history表可保留，不影响核心功能

## Open Questions

1. **Q**: 是否需要追踪Fork数量的历史？
   **A**: 暂不实现，可在后续版本添加（表结构已预留fork_count字段）

2. **Q**: 是否提供星标历史的API订阅功能？
   **A**: 不在本次范围，可作为未来功能考虑

3. **Q**: 如何处理仓库被删除或转为私有的情况？
   **A**: 保留历史数据，但标记仓库为不可访问状态

4. **Q**: 是否支持对比多个仓库的星标增长？
   **A**: 前端组件设计时考虑扩展性，但MVP版本只支持单仓库查看